<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lectures on AD2 Homepage</title><link>https://ad2-uu-se.github.io/lectures/index.html</link><description>Recent content in Lectures on AD2 Homepage</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><managingEditor>justin.pearson@it.uu.se (Justin Pearson)</managingEditor><webMaster>justin.pearson@it.uu.se (Justin Pearson)</webMaster><lastBuildDate>Wed, 19 Aug 2020 11:41:46 +0200</lastBuildDate><atom:link href="https://ad2-uu-se.github.io/lectures/index.xml" rel="self" type="application/rss+xml"/><item><title>Lecture 1</title><link>https://ad2-uu-se.github.io/lectures/lecture1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>justin.pearson@it.uu.se (Justin Pearson)</author><guid>https://ad2-uu-se.github.io/lectures/lecture1/index.html</guid><description>Today&amp;rsquo;s Topics: Introduction and asymptotic analysis Introduction/revision on algorithm analysis Worst case running time. Introduction to asymptotic analysis $O$,$\Theta$ and $\Omega$. Links to Slides and other material Slides on introduction and logistics. Slides on an asymptotic analysis. Reading Guide Chapter 1,2, 3.1 and 3.2 of CLRS3 or CLRS4 What should I know by the end of this lecture? How is the course structured? How do the assignments, help sessions and labs work?</description></item><item><title>Lecture 2</title><link>https://ad2-uu-se.github.io/lectures/lecture2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>justin.pearson@it.uu.se (Justin Pearson)</author><guid>https://ad2-uu-se.github.io/lectures/lecture2/index.html</guid><description>Today&amp;rsquo;s topics: Divide and Conquer and Algorithm Analysis Divide and Conquer, in particular how to derive a recurrence relation for the running time. More on $O$,$\Theta$, and $\Omega$ The Master theorem and how to apply it. Slides used Algorithm analysis and the master theorem Reading Guide Chapter 3 and 4 (except 4.6) of CLRS3 or Chapter 3 and 4 (except 4.6 and 4.7) of CLRS4.
You might find the following slides useful: Divide and Conquer I which has some more examples on algorithm analysis, and Divide and Conquer II that has information on the master theorem.</description></item><item><title>Lecture 3</title><link>https://ad2-uu-se.github.io/lectures/lecture3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>justin.pearson@it.uu.se (Justin Pearson)</author><guid>https://ad2-uu-se.github.io/lectures/lecture3/index.html</guid><description>Guest Lecture by Frej Knutar Lewander
Today&amp;rsquo;s topic: Graphs revision Revision on Digraphs/Digraphs: Slides 1-24 Although some of this will be revision, you should pay attention to how the graph representation effects the time complexity.
Some hints and Tips on using Python for your assignments
Slides Slides 1-24, 33-43 of Graphs.pdf Slides on Data Structures in Python Reading Guide Chapter 22, except 22.4 of CLRS3 or Chapter 20, 20.1-20.3 of CLRS4.</description></item><item><title>Lecture 4</title><link>https://ad2-uu-se.github.io/lectures/lecture4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>justin.pearson@it.uu.se (Justin Pearson)</author><guid>https://ad2-uu-se.github.io/lectures/lecture4/index.html</guid><description>Today&amp;rsquo;s topic: Dynamic Programming Dynamic programming. Introduction. Slides The slides can be found here Reading Guide Chapter 15, 15.1, 15.2 ,15.3, 15.4 of CLRS3 or Chapter 14, 14.1 , 14.2, 14.3 and 14.4 of CLRS4. What should I know by the end of this lecture? What is dynamic programming? Simple example dynamic programming as Memorisation. Some example dynamic programs.</description></item><item><title>Lecture 5</title><link>https://ad2-uu-se.github.io/lectures/lecture5/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>justin.pearson@it.uu.se (Justin Pearson)</author><guid>https://ad2-uu-se.github.io/lectures/lecture5/index.html</guid><description>Today&amp;rsquo;s topic: Dynamic Programming More on Dynamic Programming, Knapsack and an example. Pseudo Polynomial vs. Polynomial. Links to Slides The slides can be found here Reading Guide All of Chapter 15 of CLRS3 or all of Chapter 14 of CLRS4.
The textbook does not say that much about pseudo-polynomial time and the 0-1 Knapsack problem, even though it is an important concept. There there is plenty of material on the internet.</description></item><item><title>Lecture 6</title><link>https://ad2-uu-se.github.io/lectures/lecture6/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>justin.pearson@it.uu.se (Justin Pearson)</author><guid>https://ad2-uu-se.github.io/lectures/lecture6/index.html</guid><description>Today&amp;rsquo;s topics: Greedy Algorithms Introduction to Greedy Slides 1-15. We will look a greedy algorithm for the coin-change problem. This only works with certain denomination coins. You should understand the proof of why it works, and when it works. Interval scheduling. Again we met a dynamic programming solution before, here we will look at a simple greedy algorithm and understand why it is correct. Shortest Paths as a greedy algorithm. Slides 1-16 All-Pairs Shortest path using Dynamic programming (The ‣ Bellman–Ford–Moore algorithm).</description></item><item><title>Lecture 7</title><link>https://ad2-uu-se.github.io/lectures/lecture7/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>justin.pearson@it.uu.se (Justin Pearson)</author><guid>https://ad2-uu-se.github.io/lectures/lecture7/index.html</guid><description>Today&amp;rsquo;s topics: Minimal Spanning Trees. Minimal Spanning Trees, Prim&amp;rsquo;s algorithm. slides 20-49 of Greedy Algorithms II Reading Guide Chapter 23 of CLRS3 or Chapter 21 of CLRS4. What should I know by the end of this lecture? What is a minimal spanning tree? Why is the greedy algorithm correct? How does Prim&amp;rsquo;s Algorithm work?</description></item><item><title>Lectures 8,9</title><link>https://ad2-uu-se.github.io/lectures/lectures8-9/index.html</link><pubDate>Wed, 19 Aug 2020 11:41:46 +0200</pubDate><author>justin.pearson@it.uu.se (Justin Pearson)</author><guid>https://ad2-uu-se.github.io/lectures/lectures8-9/index.html</guid><description>Lecture plan and link to slides.</description></item><item><title>Lecture 10</title><link>https://ad2-uu-se.github.io/lectures/lecture10/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>justin.pearson@it.uu.se (Justin Pearson)</author><guid>https://ad2-uu-se.github.io/lectures/lecture10/index.html</guid><description>Today&amp;rsquo;s topic: Union Find Disjoint-set data-type. What is the API and some applications? Naive representation: Sets represented as trees. Representing trees as arrays, and Naive linking. Link by Size Link by Rank Path compression Analysis of run time. Slides I used slides 1 to 41 from UnionFind.
Reading Guide These notes contain useful information on greedy algorithms in general and section 5.1.4 is on Union Find. The best source is the textbook Chapter 21 (excluding section 21.</description></item><item><title>Lecture 11</title><link>https://ad2-uu-se.github.io/lectures/lecture11/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>justin.pearson@it.uu.se (Justin Pearson)</author><guid>https://ad2-uu-se.github.io/lectures/lecture11/index.html</guid><description>Today&amp;rsquo;s topic: String Matching The Rabin-Karp algorithm for fast string matching. Slides Slides Reading Guide Chapter 32 except sections 32.3 and 32.4 of CLRS3 or CLRS4. What should I know by the end of this set of lecture? How does Rabin-Karp work? What is the clever idea with hash-functions. How does Rabin-Karp compare with brute force string matching?</description></item><item><title>Lecture 12 and 13</title><link>https://ad2-uu-se.github.io/lectures/lectures12-13/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>justin.pearson@it.uu.se (Justin Pearson)</author><guid>https://ad2-uu-se.github.io/lectures/lectures12-13/index.html</guid><description>Today&amp;rsquo;s topic: P vs NP This will be a not so formal introduction to P and NP. Every computer scientist should know something about NP complete problems. If you know that a problem is NP complete, then you know that it is very hard to find an optimal solution.
The definition of P and NP The definition of Reduction and NP Hardness NP Completeness Some NP Complete Problems. What now? What courses should I take to learn more about algorithms and optimisation?</description></item></channel></rss>